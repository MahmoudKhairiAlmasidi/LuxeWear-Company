# LuxeWear-Company
Centralized Mutual Exclusion Algorithm Simulation Application

I developed this Centralized Mutual Exclusion Algorithm Simulation Application using Java to demonstrate how distributed systems manage shared resource access while ensuring data consistency and preventing race conditions. The project simulates a centralized approach where a single coordinator controls access to the critical section, ensuring that only one process executes at a time. The simulation follows a structured mechanism: first, a coordinator is selected to handle all access requests. When a process needs access, it sends a Request message containing its ID and timestamp. If no other process is in the critical section, the coordinator grants access immediately; otherwise, requests are placed in a FIFO queue and processed in order. Once a process completes execution, it sends a Release message, allowing the coordinator to grant access to the next waiting process. This implementation highlights key advantages such as simplicity, fairness, and efficiency, as it requires only three message types (Request, Grant, and Release) per access attempt, reducing communication overhead. However, it also demonstrates significant challenges, including the single point of failure problemâ€”if the coordinator crashes, the entire system halts until a new one is elected. Additionally, as the number of processes increases, the coordinator may become a bottleneck, leading to higher response times and potential delays in processing requests. I chose Java for implementation due to its robust multi-threading support, platform independence, and efficient socket communication, making it an ideal choice for simulating distributed systems. Through this project, I explored the trade-offs of centralized coordination, gaining a deeper understanding of how mutual exclusion mechanisms impact system performance, fault tolerance, and scalability.
